// This file was generated by ChatGPT.

#pragma once
#include <OpenMesh/Core/Mesh/TriMesh_ArrayKernelT.hh>
#include <OpenMesh/Core/Geometry/VectorT.hh>
#include <vector>
#include <array>
#include <cmath>
#include <limits>

#include "mesh.hpp"

// ---------- Clip convention ----------
enum class ClipConv { OpenGL, D3D_Vulkan };

// s(v) >= 0 means "inside" that clip half-space.
struct ClipPlane {
    // Evaluate signed distance-like value in homogeneous clip space.
    // We implement planes as simple linear forms s = a·x + b·y + c·z + d·w
    double a,b,c,d;
    inline double eval(const Vec4& p) const {
        return a*p[0] + b*p[1] + c*p[2] + d*p[3];
    }
};

inline std::array<ClipPlane,6> clip_planes(ClipConv conv) {
    if (conv == ClipConv::OpenGL) {
        // GL clip volume: -w <= x,y,z <= w
        return {{
            { +1, 0, 0, +1 }, //  x + w >= 0  (left)
            { -1, 0, 0, +1 }, // -x + w >= 0  (right)  -> w - x
            { 0,+1, 0, +1 },  //  y + w >= 0  (bottom)
            { 0,-1, 0, +1 },  // -y + w >= 0  (top)
            { 0, 0,+1, +1 },  //  z + w >= 0  (near)
            { 0, 0,-1, +1 },  // -z + w >= 0  (far)
        }};
    } else {
        // D3D/Vulkan: -w <= x,y <= w, 0 <= z <= w
        return {{
            { +1, 0, 0, +1 }, //  x + w >= 0
            { -1, 0, 0, +1 }, // -x + w >= 0
            { 0,+1, 0, +1 },  //  y + w >= 0
            { 0,-1, 0, +1 },  // -y + w >= 0
            { 0, 0,+1,  0 },  //  z      >= 0 (near)
            { 0, 0,-1, +1 },  // -z + w >= 0 (far)
        }};
    }
}

// ---------- Sutherland–Hodgman in homogeneous clip space ----------

struct Vtx {
    VertexHandle vh; // handle in the mesh
    Vec4       p;  // cached position (clip)
};

// Compute intersection V' between segment A->B and plane s>=0 using homogeneous lerp.
// sA = eval(A), sB = eval(B). We assume sA and sB have opposite signs.
inline Vtx intersect_on_plane(Mesh4& mesh,
                              const ClipPlane& pl,
                              const Vtx& A, const Vtx& B,
                              double eps = 1e-14)
{
    const double sA = pl.eval(A.p);
    const double sB = pl.eval(B.p);
    const double denom = (sA - sB);

    double t = (std::abs(denom) > eps) ? (sA / (sA - sB)) : 0.0; // 0..1
    // Snap near endpoints to avoid tiny sliver triangles
    if (t <= eps)  return A;
    if (t >= 1.0 - eps) return B;

    Vec4 P = (1.0 - t) * A.p + t * B.p;     // homogeneous interpolation in clip
    VertexHandle vh = mesh.add_vertex(P);     // new vertex in the mesh
    return { vh, P };
}

// Clip polygon (as a sequence of mesh vertex handles) against one plane.
// Returns the new polygon (with new vertices added to the mesh as needed).
inline std::vector<Vtx> clip_poly_against_plane(Mesh4& mesh,
                                                const std::vector<Vtx>& inPoly,
                                                const ClipPlane& pl,
                                                double eps = 0.0)
{
    std::vector<Vtx> out;
    if (inPoly.empty()) return out;

    const size_t N = inPoly.size();
    out.reserve(N + 2); // worst case adds up to 2 vertices

    auto inside = [&](const Vtx& v){ return pl.eval(v.p) >= -eps; };

    for (size_t i = 0; i < N; ++i) {
        const Vtx& S = inPoly[i];             // start
        const Vtx& E = inPoly[(i+1) % N];     // end
        const bool Sin = inside(S);
        const bool Ein = inside(E);

        if (Sin && Ein) {
            // keep E
            out.push_back(E);
        } else if (Sin && !Ein) {
            // leaving: keep intersection
            out.push_back(intersect_on_plane(mesh, pl, S, E));
        } else if (!Sin && Ein) {
            // entering: add intersection then E
            out.push_back(intersect_on_plane(mesh, pl, S, E));
            out.push_back(E);
        } else {
            // outside -> outside: keep nothing
        }
    }
    return out;
}

// Triangulate convex polygon (fan). Avoid degenerate triangles.
inline void triangulate_and_add(Mesh4& mesh, const std::vector<Vtx>& poly)
{
    if (poly.size() < 3) return;
    const VertexHandle v0 = poly[0].vh;
    for (size_t i = 1; i + 1 < poly.size(); ++i) {
        const VertexHandle v1 = poly[i].vh;
        const VertexHandle v2 = poly[i+1].vh;
        if (v0 == v1 || v1 == v2 || v2 == v0) continue; // degenerate
        std::vector<VertexHandle> tri = { v0, v1, v2 };
        mesh.add_face(tri); // may fail if triangle orientation is bad; OpenMesh will return invalid handle—safe to ignore.
    }
}

// ---------- Main: clip all triangles of the mesh in-place ----------

inline void clip_mesh_inplace(Mesh4& mesh,
                              ClipConv conv = ClipConv::OpenGL,
                              double eps = 0.0)
{
    // We will delete faces, so ensure status props are available.
    mesh.request_vertex_status();
    mesh.request_edge_status();
    mesh.request_face_status();
    mesh.request_halfedge_status();

    // Snapshot original faces to avoid iterating while mutating.
    std::vector<FaceHandle> faces;
    faces.reserve(mesh.n_faces());
    for (auto f_it = mesh.faces_begin(); f_it != mesh.faces_end(); ++f_it) {
        faces.push_back(*f_it);
    }

    const auto planes = clip_planes(conv);

    for (FaceHandle fh : faces) {
        if (!fh.is_valid() || mesh.status(fh).deleted()) continue;

        // Gather the triangle's vertices (in face order), as working polygon
        std::vector<Vtx> poly; poly.reserve(8);
        for (auto vh : mesh.fv_range(fh)) {
            const Vec4 p = mesh.point(vh);
            poly.push_back({ vh, p });
        }

        // Clip against 6 planes
        for (const ClipPlane& pl : planes) {
            poly = clip_poly_against_plane(mesh, poly, pl, eps);
            if (poly.empty()) break; // fully clipped
        }

        // Remove original face
        mesh.delete_face(fh, /*delete_isolated_vertices=*/false);

        // If anything remains, triangulate and add
        if (!poly.empty() && poly.size() >= 3) {
            triangulate_and_add(mesh, poly);
        }
    }

    // Clean up deleted elements; keep unused vertices if you like
    mesh.garbage_collection(/*v*/true, /*e*/true, /*f*/true);
}

